"""
Generated by https://app.quicktype.io/ , do not modify!
"""

from dataclasses import dataclass
from enum import Enum
from typing import List, Optional, Any, TypeVar, Callable, Type, cast

T = TypeVar("T")
EnumT = TypeVar("EnumT", bound=Enum)


def from_list(f: Callable[[Any], T], x: Any) -> List[T]:
    assert isinstance(x, list)
    return [f(y) for y in x]


def from_int(x: Any) -> int:
    assert isinstance(x, int) and not isinstance(x, bool)
    return x


def from_str(x: Any) -> str:
    assert isinstance(x, str)
    return x


def from_none(x: Any) -> Any:
    assert x is None
    return x


def from_union(fs, x):
    for f in fs:
        try:
            return f(x)
        except:
            pass
    assert False


def to_enum(c: Type[EnumT], x: Any) -> EnumT:
    assert isinstance(x, c)
    return x.value


def to_class(c: Type[T], x: Any) -> dict:
    assert isinstance(x, c)
    return cast(Any, x).to_dict()


class CursorKind(Enum):
    ARRAY_SUBSCRIPT_EXPR = "CursorKind.ARRAY_SUBSCRIPT_EXPR"
    BINARY_OPERATOR = "CursorKind.BINARY_OPERATOR"
    BREAK_STMT = 'CursorKind.BREAK_STMT'
    CALL_EXPR = "CursorKind.CALL_EXPR"
    CASE_STMT = 'CursorKind.CASE_STMT'
    CHARACTER_LITERAL = "CursorKind.CHARACTER_LITERAL"
    COMPOUND_ASSIGNMENT_OPERATOR = "CursorKind.COMPOUND_ASSIGNMENT_OPERATOR"
    COMPOUND_STMT = "CursorKind.COMPOUND_STMT"
    CONDITIONAL_OPERATOR = "CursorKind.CONDITIONAL_OPERATOR"
    CSTYLE_CAST_EXPR = "CursorKind.CSTYLE_CAST_EXPR"
    CXX_UNARY_EXPR = "CursorKind.CXX_UNARY_EXPR"
    DECL_REF_EXPR = "CursorKind.DECL_REF_EXPR"
    DECL_STMT = "CursorKind.DECL_STMT"
    DEFAULT_STMT = 'CursorKind.DEFAULT_STMT'
    FLOATING_LITERAL = "CursorKind.FLOATING_LITERAL"
    FOR_STMT = "CursorKind.FOR_STMT"
    IF_STMT = "CursorKind.IF_STMT"
    INIT_LIST_EXPR = "CursorKind.INIT_LIST_EXPR"
    INTEGER_LITERAL = "CursorKind.INTEGER_LITERAL"
    MEMBER_REF = "CursorKind.MEMBER_REF"
    MEMBER_REF_EXPR = "CursorKind.MEMBER_REF_EXPR"
    NULL_STMT = "CursorKind.NULL_STMT"
    PAREN_EXPR = "CursorKind.PAREN_EXPR"
    PARM_DECL = "CursorKind.PARM_DECL"
    RETURN_STMT = "CursorKind.RETURN_STMT"
    STRING_LITERAL = "CursorKind.STRING_LITERAL"
    SWITCH_STMT = "CursorKind.SWITCH_STMT"
    TYPE_REF = "CursorKind.TYPE_REF"
    UNARY_OPERATOR = "CursorKind.UNARY_OPERATOR"
    UNEXPOSED_EXPR = "CursorKind.UNEXPOSED_EXPR"
    VAR_DECL = "CursorKind.VAR_DECL"
    DO_STMT = "CursorKind.DO_STMT"
    ENUM_CONSTANT_DECL = "CursorKind.ENUM_CONSTANT_DECL"
    FIELD_DECL = "CursorKind.FIELD_DECL"
    WHILE_STMT = "CursorKind.WHILE_STMT"
    ENUM_DECL = "CursorKind.ENUM_DECL"
    STRUCT_DECL = "CursorKind.STRUCT_DECL"
    FUNCTION_DECL = "CursorKind.FUNCTION_DECL"
    TYPEDEF_DECL = "CursorKind.TYPEDEF_DECL"


@dataclass
class Child4:
    kind: CursorKind
    location: List[int]
    file: str
    children: List['LLVMGeneratedModel']
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Child4':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(LLVMGeneratedModel.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return Child4(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(LLVMGeneratedModel, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class Child3:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[Child4]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Child3':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(Child4.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return Child3(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(Child4, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class Child2:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[Child3]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Child2':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(Child3.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return Child2(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(Child3, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class Child1:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[Child2]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'Child1':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(Child2.from_dict, obj.get("children"))
        return Child1(kind, location, file, children)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(Child2, x), self.children)}
        return result


@dataclass
class BraggadociousChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[Child1]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'BraggadociousChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(Child1.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return BraggadociousChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(Child1, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class MischievousChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[BraggadociousChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'MischievousChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(BraggadociousChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return MischievousChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(BraggadociousChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class FriskyChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[MischievousChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'FriskyChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(MischievousChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return FriskyChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(MischievousChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class MagentaChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[FriskyChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'MagentaChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(FriskyChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return MagentaChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(FriskyChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class CunningChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[MagentaChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'CunningChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(MagentaChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return CunningChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(MagentaChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class AmbitiousChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[CunningChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'AmbitiousChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(CunningChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return AmbitiousChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(CunningChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class HilariousChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[AmbitiousChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'HilariousChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(AmbitiousChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return HilariousChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(AmbitiousChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class IndecentChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[HilariousChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'IndecentChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(HilariousChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return IndecentChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(HilariousChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class IndigoChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[IndecentChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'IndigoChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(IndecentChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return IndigoChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(IndecentChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class StickyChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[IndigoChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'StickyChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(IndigoChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return StickyChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(IndigoChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class TentacledChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[StickyChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'TentacledChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(StickyChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return TentacledChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(StickyChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class FluffyChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[TentacledChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'FluffyChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(TentacledChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return FluffyChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(TentacledChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class PurpleChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[FluffyChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'PurpleChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(FluffyChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return PurpleChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(FluffyChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


@dataclass
class LLVMGeneratedModelChild:
    kind: CursorKind
    location: List[int]
    file: str
    children: List[PurpleChild]
    spelling: str

    @staticmethod
    def from_dict(obj: Any) -> 'LLVMGeneratedModelChild':
        assert isinstance(obj, dict)
        kind = CursorKind(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(PurpleChild.from_dict, obj.get("children"))
        spelling = from_str(obj.get("spelling"))
        return LLVMGeneratedModelChild(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": to_enum(CursorKind, self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(PurpleChild, x), self.children),
                        "spelling": from_str(self.spelling)}
        return result


@dataclass
class LLVMGeneratedModel:
    kind: str
    location: List[int]
    file: str
    children: List[LLVMGeneratedModelChild]
    spelling: Optional[str] = None

    @staticmethod
    def from_dict(obj: Any) -> 'LLVMGeneratedModel':
        assert isinstance(obj, dict)
        kind = from_str(obj.get("kind"))
        location = from_list(from_int, obj.get("location"))
        file = from_str(obj.get("file"))
        children = from_list(LLVMGeneratedModelChild.from_dict, obj.get("children"))
        spelling = from_union([from_str, from_none], obj.get("spelling"))
        return LLVMGeneratedModel(kind, location, file, children, spelling)

    def to_dict(self) -> dict:
        result: dict = {"kind": from_str(self.kind), "location": from_list(from_int, self.location),
                        "file": from_str(self.file),
                        "children": from_list(lambda x: to_class(LLVMGeneratedModelChild, x), self.children)}
        if self.spelling is not None:
            result["spelling"] = from_union([from_str, from_none], self.spelling)
        return result


def llvm_generated_model_from_dict(s: Any) -> LLVMGeneratedModel:
    return LLVMGeneratedModel.from_dict(s)


def llvm_generated_model_to_dict(x: LLVMGeneratedModel) -> Any:
    return to_class(LLVMGeneratedModel, x)


cursor_kind_dict = {
    CursorKind.ARRAY_SUBSCRIPT_EXPR: "数组下标表达式",
    CursorKind.BINARY_OPERATOR: "二元运算符",
    CursorKind.BREAK_STMT: "break 语句",
    CursorKind.CALL_EXPR: "函数调用表达式",
    CursorKind.CASE_STMT: "case 语句",
    CursorKind.CHARACTER_LITERAL: "字符字面量",
    CursorKind.COMPOUND_ASSIGNMENT_OPERATOR: "复合赋值运算符",
    CursorKind.COMPOUND_STMT: "复合语句",
    CursorKind.CONDITIONAL_OPERATOR: "条件（三元）运算符",
    CursorKind.CSTYLE_CAST_EXPR: "C 风格的类型转换表达式",
    CursorKind.CXX_UNARY_EXPR: "C++ 一元运算表达式",
    CursorKind.DECL_REF_EXPR: "声明引用表达式",
    CursorKind.DECL_STMT: "声明语句",
    CursorKind.DEFAULT_STMT: "default 语句",
    CursorKind.FLOATING_LITERAL: "浮点数字面量",
    CursorKind.FOR_STMT: "for 循环语句",
    CursorKind.IF_STMT: "if 语句",
    CursorKind.INIT_LIST_EXPR: "初始化列表表达式",
    CursorKind.INTEGER_LITERAL: "整数字面量",
    CursorKind.MEMBER_REF: "成员引用",
    CursorKind.MEMBER_REF_EXPR: "成员引用表达式",
    CursorKind.NULL_STMT: "空语句",
    CursorKind.PAREN_EXPR: "括号表达式",
    CursorKind.PARM_DECL: "参数声明",
    CursorKind.RETURN_STMT: "return 语句",
    CursorKind.STRING_LITERAL: "字符串字面量",
    CursorKind.SWITCH_STMT: "switch 语句",
    CursorKind.TYPE_REF: "类型引用",
    CursorKind.UNARY_OPERATOR: "一元运算符",
    CursorKind.UNEXPOSED_EXPR: "未暴露的表达式",
    CursorKind.VAR_DECL: "变量声明",
    CursorKind.DO_STMT: "do 循环语句",
    CursorKind.ENUM_CONSTANT_DECL: "枚举常量声明",
    CursorKind.FIELD_DECL: "字段声明",
    CursorKind.WHILE_STMT: "while 循环语句",
    CursorKind.ENUM_DECL: "枚举声明",
    CursorKind.STRUCT_DECL: "结构体声明",
    CursorKind.FUNCTION_DECL: "函数声明",
    CursorKind.TYPEDEF_DECL: "类型定义声明"
}
cursor_kind_ignore_set = {
    CursorKind.STRING_LITERAL,
    CursorKind.DECL_REF_EXPR,
    CursorKind.CHARACTER_LITERAL,
    CursorKind.UNEXPOSED_EXPR
}
